<!DOCTYPE html>
<html>
<head>
    <title>Control Panel</title>
    <link href="{{ url_for('static', filename='styles/index.css') }}" rel="stylesheet" type="text/css"/>
    <meta charset="UTF-8">
</head>
<body>
    <div class="header">
      <h2>üõ∞Ô∏è –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –Ω–µ—Ñ—Ç–µ–ø—Ä–æ–≤–æ–¥–∞ ‚Äî ArUco 10√ó10</h2>
      <div class="controls">
        <button id="start" class="btn-start" onclick="startMission()">‚ñ∂Ô∏è –°—Ç–∞—Ä—Ç</button>
        <button id="stop" class="btn-stop" onclick="stopMission()">‚èπÔ∏è –°—Ç–æ–ø</button>
        <button id="kill" class="btn-kill" onclick="kill()">üíÄ Kill</button>
        <span id="status" class="status">–°—Ç–∞—Ç—É—Å: idle</span>
      </div>
    </div>
    
    <div id="map-container">
      <canvas id="map" width="550" height="550"></canvas>
    </div>
    
    <div class="legend">
      <div class="legend-item"><span class="legend-color drone-color"></span> –î—Ä–æ–Ω</div>
      <div class="legend-item"><span class="legend-color tap-color"></span> –í—Ä–µ–∑–∫–∞</div>
      <div class="legend-item"><span class="legend-color marker-color"></span> ArUco-–º–∞—Ä–∫–µ—Ä</div>
      <div class="legend-item">–®–∞–≥ —Å–µ—Ç–∫–∏: 1 –º</div>
    </div>
    
    <h3>–ù–∞–π–¥–µ–Ω–Ω—ã–µ –≤—Ä–µ–∑–∫–∏:</h3>
    <ul id="taps-list"></ul>
    
    <script>
      // –ù–∞—Å—Ç—Ä–æ–π–∫–∏
      const MAP_SIZE_M = 10;           // 10√ó10 –º
      const PX_PER_M = 50;             // –º–∞—Å—à—Ç–∞–±: 1 –º = 50 px
      const OFFSET_X = 25;             // –æ—Ç—Å—Ç—É–ø —Å–ª–µ–≤–∞/—Å–≤–µ—Ä—Ö—É (–¥–ª—è –º–∞—Ä–∫–µ—Ä–æ–≤ —É –∫—Ä–∞—è)
      const OFFSET_Y = 25;
      
      let drone = { x: 0, y: 0, yaw: -1.57 };
      let taps = [];                   // [{x, y}, ...]
      let route = [];                  // [{x, y}, ...]
      let status = 'idle';
      let markers = [];   // [{id, x, y, z, length}, ...]

      const canvas = document.getElementById('map');
      const ctx = canvas.getContext('2d');
      
      // --- –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –∫–∞—Ä—Ç—ã ---
      function drawMap() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (markers.length === 0) {
          // Fallback: draw placeholder grid if no map yet
          drawFallbackGrid();
          drawDroneAndTaps();
          return;
        }

        // üîç Determine map bounds from real markers
        const xs = markers.map(m => m.x);
        const ys = markers.map(m => m.y);
        const minX = Math.min(...xs);
        const maxX = Math.max(...xs);
        const minY = Math.min(...ys);
        const maxY = Math.max(...ys);

        // Add small padding (e.g., 0.5 m)
        const padding = 0.5;
        const mapWidth = maxX - minX + 2 * padding;
        const mapHeight = maxY - minY + 2 * padding;

        // Fit map to canvas (550√ó550) with margins
        const margin = 30;
        const scaleX = (canvas.width - 2 * margin) / mapWidth;
        const scaleY = (canvas.height - 2 * margin) / mapHeight;
        const scale = Math.min(scaleX, scaleY); // preserve aspect ratio

        // Compute offsets so map is centered
        const offsetX = margin + (canvas.width - 2 * margin - mapWidth * scale) / 2;
        const offsetY = margin + (canvas.height - 2 * margin - mapHeight * scale) / 2;

        // Helper: world ‚Üí pixel
        function toPx(worldX, worldY) {
          const px = offsetX + (worldX - (minX - padding)) * scale;
          const py = canvas.height - (offsetY + (worldY - (minY - padding)) * scale); // flip Y: 0 at bottom
          return { x: px, y: py };
        }

        // üî∑ Draw axes grid (light gray, 1m steps)
        ctx.strokeStyle = '#e0e0e0';
        ctx.lineWidth = 1;

        // Draw vertical lines (X direction)
        for (let x = Math.floor(minX - padding); x <= Math.ceil(maxX + padding); x++) {
          const p = toPx(x, minY - padding);
          const q = toPx(x, maxY + padding);
          ctx.beginPath();
          ctx.moveTo(p.x, p.y);
          ctx.lineTo(q.x, q.y);
          ctx.stroke();
        }

        // Draw horizontal lines (Y direction)
        for (let y = Math.floor(minY - padding); y <= Math.ceil(maxY + padding); y++) {
          const p = toPx(minX - padding, y);
          const q = toPx(maxX + padding, y);
          ctx.beginPath();
          ctx.moveTo(p.x, p.y);
          ctx.lineTo(q.x, q.y);
          ctx.stroke();
        }

        // üî≤ Draw real ArUco markers
        markers.forEach(m => {
          const center = toPx(m.x, m.y);
          const half = (m.length / 2) * scale;
          // Draw square (rotated 0¬∞ ‚Äî assume upright)
          ctx.fillStyle = '#6c757d';
          ctx.fillRect(center.x - half, center.y - half, 2 * half, 2 * half);
          ctx.strokeStyle = '#495057';
          ctx.lineWidth = 1;
          ctx.strokeRect(center.x - half, center.y - half, 2 * half, 2 * half);
          // ID label
          ctx.fillStyle = '#fff';
          ctx.font = '10px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(`#${m.id}`, center.x, center.y);
        });

        // ‚ñ∂Ô∏è Draw route (if any)
        if (route.length > 1) {
          ctx.strokeStyle = '#00FF00'; // green
          ctx.lineWidth = 7;
          ctx.beginPath();
          route.forEach((pt, i) => {
            const p = toPx(pt.x, pt.y);
            if (i === 0) ctx.moveTo(p.x, p.y);
            else ctx.lineTo(p.x, p.y);
          });
          ctx.stroke();
        }

        // üî¥ Draw taps
        ctx.fillStyle = '#dc3545';
        taps.forEach(t => {
          // Assuming t is {x, y} or just [x, y, z...]
          const x = typeof t === 'object' ? t.x : t[0];
          const y = typeof t === 'object' ? t.y : t[1];
          const p = toPx(x, y);
          ctx.beginPath();
          ctx.arc(p.x, p.y, 8, 0, 2 * Math.PI);
          ctx.fill();
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 2;
          ctx.stroke();
        });

        // üõ∞Ô∏è Draw drone
        const d = toPx(drone.x, drone.y);
        ctx.save();
        ctx.translate(d.x, d.y);
        ctx.rotate(-drone.yaw); // rotate triangle
        ctx.fillStyle = '#007bff';
        ctx.beginPath();
        ctx.moveTo(0, -10);
        ctx.lineTo(-6, 8);
        ctx.lineTo(6, 8);
        ctx.closePath();
        ctx.fill();
        ctx.restore();

        // Axis labels (optional)
        ctx.fillStyle = '#333';
        ctx.font = '12px Arial';
        ctx.textAlign = 'left';
        ctx.fillText('X ‚Üí', canvas.width - 40, canvas.height - 10);
        ctx.save();
        ctx.translate(15, canvas.height - 15);
        ctx.rotate(-Math.PI / 2);
        ctx.textAlign = 'center';
        ctx.fillText('Y ‚Üë', 0, 0);
        ctx.restore();
      }

      // Fallback: draw 10√ó10 grid if no map yet
      function drawFallbackGrid() {
        const MAP_SIZE_M = 10;
        const PX_PER_M = 50;
        const OFFSET_X = 25;
        const OFFSET_Y = 25;

        ctx.strokeStyle = '#e0e0e0';
        ctx.lineWidth = 1;
        for (let i = 0; i <= MAP_SIZE_M; i++) {
          const x = OFFSET_X + i * PX_PER_M;
          const y0 = OFFSET_Y;
          const y1 = OFFSET_Y + MAP_SIZE_M * PX_PER_M;
          ctx.beginPath();
          ctx.moveTo(x, y0); ctx.lineTo(x, y1);
          ctx.moveTo(y0, x); ctx.lineTo(y1, x);
          ctx.stroke();
        }

        // Grid markers (placeholder)
        ctx.fillStyle = '#ccc';
        for (let i = 0; i < 10; i++) {
          for (let j = 0; j < 10; j++) {
            ctx.fillRect(OFFSET_X + i * PX_PER_M - 2, OFFSET_Y + j * PX_PER_M - 2, 4, 4);
          }
        }
      }

      function drawDroneAndTaps() {
        // Reuse existing drone/tap drawing logic, but with fallback coords
        const MAP_SIZE_M = 10;
        const PX_PER_M = 50;
        const OFFSET_X = 25;
        const OFFSET_Y = 25;

        const dx = OFFSET_X + drone.x * PX_PER_M;
        const dy = OFFSET_Y + (MAP_SIZE_M - drone.y) * PX_PER_M;
        ctx.save();
        ctx.translate(dx, dy);
        ctx.rotate(-drone.yaw);
        ctx.fillStyle = '#007bff';
        ctx.beginPath();
        ctx.moveTo(0, -10);
        ctx.lineTo(-6, 8);
        ctx.lineTo(6, 8);
        ctx.closePath();
        ctx.fill();
        ctx.restore();


        ctx.fillStyle = '#dc3545';
        taps.forEach(t => {
          const x = typeof t === 'object' ? t.x : t[0];
          const y = typeof t === 'object' ? t.y : t[1];
          const px = OFFSET_X + x * PX_PER_M;
          const py = OFFSET_Y + (MAP_SIZE_M - y) * PX_PER_M;
          ctx.beginPath();
          ctx.arc(px, py, 8, 0, 2 * Math.PI);
          ctx.fill();
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 2;
          ctx.stroke();
        });
      }
      
        // –î—Ä–æ–Ω (—Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫, –æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–æ yaw)
        const dx = OFFSET_X + drone.x * PX_PER_M;
        const dy = OFFSET_X + (MAP_SIZE_M - drone.y) * PX_PER_M; // ‚Üê‚ö†Ô∏è Fixed: was OFFSET_Y before
        ctx.save();
        ctx.translate(dx, dy);
        ctx.rotate(-drone.yaw);
        ctx.fillStyle = '#007bff';
        ctx.beginPath();
        ctx.moveTo(0, -10);
        ctx.lineTo(-6, 8);
        ctx.lineTo(6, 8);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      
        // –ü–æ–¥–ø–∏—Å–∏ –æ—Å–µ–π
        ctx.fillStyle = '#333';
        ctx.font = '12px Arial';
        ctx.fillText('X ‚Üí', OFFSET_X + MAP_SIZE_M * PX_PER_M + 10, OFFSET_Y + MAP_SIZE_M * PX_PER_M + 15);
        ctx.save();
        ctx.translate(10, OFFSET_Y + MAP_SIZE_M * PX_PER_M + 10);
        ctx.rotate(-Math.PI / 2);
        ctx.fillText('Y ‚Üë', 0, 0);
        ctx.restore();
      

      async function fetchMap() {
        try {
          const res = await fetch('/map');
          const data = await res.json();
          markers = data.markers || [];
        } catch (e) {
          console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∫–∞—Ä—Ç—É ArUco');
          markers = [];
        }
      }

      // --- –ó–∞–ø—Ä–æ—Å—ã –∫ —Å–µ—Ä–≤–µ—Ä—É ---
      async function fetchDrone() {
        try {
          const res = await fetch('/drone');
          const data = await res.json();
          drone = { x: data.x, y: data.y, yaw: data.yaw - 1.57 };
        } catch (e) {
          console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –ø–æ–∑–∏—Ü–∏—é –¥—Ä–æ–Ω–∞');
        }
      }
      
      async function fetchTaps() {
        try {
          const res = await fetch('/taps');
          const data = await res.json(); // [{x:1.2, y:1.5}, ...]
          taps = data;
        } catch (e) {
          console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –≤—Ä–µ–∑–æ–∫', e);
        }
      }
      
      async function fetchStatus() {
        try {
          const res = await fetch('/status');
          const data = await res.json();
          status = data.status || 'unknown';
          document.getElementById('status').innerText = `–°—Ç–∞—Ç—É—Å: ${status}`;
          document.getElementById('status').className = `status status-${status}`;
          const startBtn = document.getElementById('start');
          startBtn.disabled = (status === 'flying');
        } catch (e) {
          console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç—É—Å');
        }
      }
      
      // ‚úÖ NEW: Fetch route (list of points)
      async function fetchRoute() {
        try {
          const res = await fetch('/route');
          const data = await res.json(); // expects: [{x: ..., y: ..., yaw: ...}, ...]
          route = data;
        } catch (e) {
          console.warn(e);
          route = [];
        }
      }
      
      // --- –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ ---
      function update() {
        Promise.all([fetchDrone(), fetchTaps(), fetchStatus(), fetchRoute(), fetchMap()]).then(() => {
          drawMap();
          updateTapsList();
        });
      }
      
      function updateTapsList() {
        const list = document.getElementById('taps-list');
        list.innerHTML = taps.length === 0
          ? '<li>–í—Ä–µ–∑–∫–∏ –Ω–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω—ã</li>'
          : taps.map((t, i) => `<li><strong>#${i+1}</strong>: (${t.x.toFixed(2)}, ${t.y.toFixed(2)}) –º</li>`).join('');
      }
      
      // --- –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ ---
      async function sendCommand(cmd) {
        try {
          await fetch('/command', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ command: cmd })
          });
        } catch (e) {
          console.log(e)
          alert('–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∫–æ–º–∞–Ω–¥—ã');
        }
      }
      function startMission() { sendCommand('start'); }
      function stopMission()  { sendCommand('stop'); }
      function kill()         { sendCommand('kill'); }
      
      // --- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è ---
      drawMap();
      setInterval(update, 300);
      
      // –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—è –∫–æ–ª–µ—Å–æ–º (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
      canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        // zoom logic can be added later
      }, { passive: false });
      </script>
    
</body>
</html>
